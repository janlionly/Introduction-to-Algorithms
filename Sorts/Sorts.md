# Sorts(从小到大)

## 1. Insertion-Sort

插入排序: 将输入序列分成左右两切片, 左切片A[0...j-1]是已排序的, 右切片A[j...n]未排序,算法思路是从右切片逐个取数通过对比插入到左切片相应的位置.

### 分解

```
	从未排序的切片中依次取数;

​	取出的数通过对比插入到左切片相应的位置;
```

- 将此数key从原序列位置拿出放入临时位置上, 已排序末端到起端位置[j-1...0], 如果key比i位置上的X要大, 则把X往前移到i+1位置上,以此类推, 直到到达起端位置前A[i]比key小时停止移动. 

- 演示图: 

    key = 9

  - [1, 2, 5, 7, 10, **11**, 9, ...] , 下标i = 5, X = 11
  - [1, 2, 5, 7, 10, ~~11~~, **11**, ...], X = 11, 比key大, 11往前移一位
  - [1, 2, 5, 7, ~~10~~, **10**, 11, ...], 下标i = 4, X = 10, 比key大, 10往前移一位
  - [1, 2, 5, 7, ~~10~~, 10, 11, ...], 下标i = 3, X = 7, 比key小, 停止移动
  - [1, 2, 5, 7, key, 10, 11, ...], 此时把key放入数据往前移动后腾出的空位(对应下标为i + 1)

```swift
    func insertionSort(array: [Int]) -> [Int] {
        var A = array
        for j in 1..<array.count {
            let key = array[j]
            var i = j - 1
            // move forward to find target index to insert
            while i >= 0 && A[i] > key {
                A[i + 1] = A[i]
                i = i - 1
            }
            A[i + 1] = key
        }
        return A
    }
```

### 时间复杂度

从分解步骤中, 第一步从未排序的数中逐个取数需要n步, 取出每一个数进行移动插入最多需要n步, 所以总共需要 n * n步, 时间复杂度为O(n^2).



